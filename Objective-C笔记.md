1. OC 相对于 C

   1. 在 C 的基础之上新增了 1 小部分面向对象的语法。
   2. 将 C 的复杂的、繁琐的、可恶的语法封装的更为简单。
   3. OC 完全兼容 C 语言。

2. OC 程序的源文件的后缀名是 .m m 代表 message 代表 OC 中最重要的 1个机制 消息机制。

   C 程序的源文件的后缀名 .c

3. main 函数仍然是 OC 程序的入口和出口。

   int 类型的返回值 代表程序的结束状态。

   main 函数的参数：仍然可以接收用户在运行程序的时候传递数据给程序，参数也可以不要

4. import指令：

   1. 以 # 号开头，是 1 个预处理指令。
   2. 作用：是 #include 指令的增强版，将文件的内容在预编译的时候拷贝写指令的地方。
   3. 增强：同一个文件无论 #import 多少次，只会包含一次。
      1. 如果 #include 指令要实现这个效果，就必须要配合条件编译指令来实现。
      2. 而 #import 指令只需要直接包含就可以，其他什么都不需要做。
   4. 简要原理： #import 指令在包含文件的时候，底层会先判断这个文件是否被包含，如果被包含就会略过，否则才会包含。

5. 框架

   1. 是一个功能集 苹果或者第三方事先将一些程序在开发程序的时候经常要用到的功能事先写好，把这些功能封装在一个一个的类或者函数之中，这些函数和类的集合就叫做框架。

      有点像 C 语言的函数库。

   2. Foundation 框架。

      Foundation：基础 基本。这个框架中提供一些最基础的功能，输入和输出，一些数据类型。

      Foundation.h 这个文件中包含了 Foundation 框架中的其他的所有的头文件。

      所以，我们只要包含 Foundation.h 就相当于包含了 Foundation 框架中所有的头文件。

      那么 Foundation 框架中的所有函数和类就可以直接使用。

6. @autoreleasepool  是自动释放池

   可以将代码写在自动释放池之中，或者干脆把这个自动释放池删除，不会有任何影响。

7. NSLog 函数

   1. 作用：是 printf 函数的增强版，向控制台输出信息

- OC 程序的编译、连接、执行
  - 在 .m 文件中写上符合 OC 语法规范的源代码
  - 使用编译器将源代码编译为目标文件
    - cc -c xx.m
    - 预处理。检查语法。编译。
  - 链接
    - cc xx.o
    - 如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉编译器去那一个框架中找这个函数或者类。
    - cc xx.o -framework 框架名称
    - 程序中用到了那一个框架中的功能，那么就在这个地方告诉编译器。
  - 链接成功以后，就会生成一个 a.out 可执行文件，执行就可以了。

- OC 中的数据类型
  - OC 中支持 C 语言中的所有的数据类型
    - 基本数据类型 int double float char
    - 构造类型 数组 结构体 枚举
    - 指针类型 int *p1
    - 空类型 void
    - typedef 自定义类型

- 如何设计一个类：
  - 类的作用：用来描述一群具有相同特征和行为的事物。

  - 设计类的三要素：
    - 类的名字，你要描述的这类事物叫什么名字
    - 这类事物具有的相同的特征，这类事物拥有什么
    - 这类事物具有的共同的行为

  - 如何定义类

    - 位置：直接写在源文件之中，不要写在 main 函数之中

    - 类的定义分为两个部分

      - 类的声明

        @interface 类名 ：NSObject

        {

        ​	这类事物具有的共同的特征，将他们定义为变量。

        }

        功能就是一个方法，将方法的声明写在这里。

        @end

      - 类的实现

        @implementation 类名

        将方法的实现写在这里。

        @end

    - 几点注意

      - 类必须要有声明和实现

      - 类名用描述的事物的名称来命名

        类名的每一个单词的首字母必须要以大写开头。

      - 用来表示这类事物的共同特征的变量必须要定义在 @interface 的大括弧之中

      - 定义在大括弧之中用来表示这类事物的共同的特征的变量我们叫做 熟悉/成员变量/实例变量/字段。。。

      - 为类定义属性的时候，属性的名词必须要以 _ 开头 下划线开头。

      - 语法是固定的。

        @interface 类名：NSObject

        {

        ​	这类事物具有的共同的特征定义为变量

        ​	数据类型 变量名1；

        ​	数据类型 变量名2；

        ​	。。。

        }

        @end

        @implement 类名

        @end

- 类是无法直接使用的，如果非要使用这个类的话，就必须要先找到这个类中的一个具体存在，再使用这个对象。

  类和对象的关系：类中有的东西，这个类的对象也有，不会多也不会少，对象就可以使用，这个时候我们就可以使用对象里面的对象。

- 如何创建一个类的对象

  语法：     类名 *对象名 = 【类名 new】；

  ​		Person *p1 = 【Person new】；

  ​		根据 Person 这个类的模版，创建了一个对象名字叫做 p1.

  ​		p1 对象的特点：

  ​			可以直接使用

  ​			类中定义的东西，这个对象中也有

- 如何使用对象：

  如何访问对象的属性：

  - 默认情况下，对象的属性是不允许被外界直接访问的。如果允许对象的属性可以被外界访问，那么就再声明属性的是加一个 @public 关键字。

  - 访问对象的属性的方式

    对象名->属性名 = 值；

    对象名->属性名；

    （*对象名）.属性名；
    尽量使用 ->

- 定义一个类

  - 分为类的声明和实现

    @interface 类名 ：NSObject {

    ​	属性 属性表示类的特征。

    }

    方法的声明；方法表示类的功能。

    @end

    @implementation 类名

    方法的实现；

    @end

- 一类事物不仅具有相同的特征还具有相同的行为

  - 行为就是一个功能，C语言中使用函数来表示一个功能。OC的类具有的行为，我们使用方法来表示。
  - 方法和函数都表示一个功能。

- 无参数的方法。

  - 声明

    - 位置：在@interface的大括弧的外面
    - 语法：
      - -（返回值类型）方法名称；
      - -(void) run;
      - 表示声明了一个无返回值并且无参数的方法，方法名字叫做 run

  - 实现

    - 位置：在@implementation之中实现
    - 实现的语法：将方法的声明拷贝到@implementation之中，去掉分号，追加大括号一对，将方法实现的代码写在大括弧之中

  - 调用

    - 方法是无法直接调用的，因为类不能直接使用，必须要先创建对象，那么这个对象中就有类中的属性和方法

    - 调用对象的方法

      【对象名 方法名】；

- 带一个参数的方法

  - 声明
    - 位置：在@interface的大括弧外面
    - 语法：
    - -（返回值类型）方法名称：（参数类型）形参名称；
    - -(void) eat:(NSString *) foodname;
    - 定义了一个方法，这个方法没有返回值
    - 这个方法的名字叫做 eat：
    - 这个方法有一个参数，类型是 NSString * 类型的，参数的名字叫做 foodName
  - 实现
    - 位置：在@implementation之中实现
    - 实现的语法：将方法的声明拷贝到@implementation之中，去掉分号，追加大括号一对，将方法实现的代码写在大括弧之中
  - 调用
    - 方法是无法直接调用的，因为类不能直接使用，必须要先创建对象，那么这个对象中就有类中的属性和方法
    - 调用的语法
    - 【对象名 方法名：实参】
    - 方法头中的数据类型都要用一个小括弧扩、括起来
    - -（返回值类型）方法名称：（参数类型）参数名称；

- 带多个参数的方法。

  - 声明
    - 位置：在@interface的大括弧外面
    - 语法
    - -（返回值类型）方法名称：（参数类型）形参名称1:（参数类型）参数名称2:（参数类型）参数名称3
    - 表示声明了一个方法 这个方法的返回值类型是 int 类型的
  - 调用
    - 【对象名 方法名：实参1】



- 内存中的五大区域
  - 栈 存储局部变量
  - 堆 程序员手动申请的字节空间 malloc calloc realloc 函数
  - BSS段 存储未被初始化的全局变量 静态变量
  - 数据段（常量区）存储已被初始化的全局 静态变量 常量数据
  - 代码段 存储代码。存储程序的代码。
- 类加载
  - 在创建对象的时候，肯定需要访问类
  - 声明一个类的指针变量也会访问类
  - 在程序运行期间 当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程叫做类加载。
  - 只有类在第一次被访问的时候，才会做类加载。
  - 一旦类被加载到代码段以后，直到程序结束的时候才会被释放。
- 对象在内存中究竟是如何存储
  - 假设下面这个写在函数之中
  - Person *p1 = [Person new];
  - Person *p1; 会在栈内存中申请一块空间，在栈内存中声明一个 Person 类型的指针变量 p1，p1 是一个指针变量，那么只能储存地址
  - [Person new]; 真正在内存中创建对象的其实是这句代码。 
    - New 做的事情：
      - 在堆内存中申请一块合适大小的空间
      - 在这个空间中根据类的模版创建对象
        - 类模版中定义了什么属性，就把这些属性依次的声明在对象之中
        - 对象中还有另外一个属性，叫做 isa，是一个指针，指向对象所属的类在代码段中的地址 
      - 初始化对象的属性
        - 如果属性的类型是基本数据类型，那么就赋值为 0
        - 如果属性的类型是C语言的指针类型，那么就赋值为NULL
        - 如果属性的类型是OC的类指针类型，那么就赋值为nil
      - 返回对象的地址
  - 注意
    - 对象中只有属性，而没有方法，自己类的属性外加一个isa指针指向代码段中的类
    - 如何访问对象的属性
      - 指针名->属性名
      - 根据指针，找到指针指向的对象，再找到对象中的属性来访问
    - 如何调用方法
      - 【指针名 方法名】；
      - 现根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类。
- 为什么不把方法存储在对象之中？ 
  - 因为每一个对象的方法的代码实现都是一模一样的，没有必要为每一个对象都保存一个方法，这样的话就太浪费空间了
- 对象的属性的默认值
  - 如果我们创建一个对象，没有为对象的属性赋值，那么这个对象的属性是有值的。
  - 如果属性的类型是基本数据类型，那么默认值是0
  - 如果属性的类型是C指针类型，那么默认值是NULL
  - 如果属性的类型是OC指针类型，那么默认值是nil
- NULL
  - 只能作为指针变量的值，如果一个指针变量的值是NULL值的代表，代表这个指针不指向内存中的任何一块空间
  - NULL 其实等价于0，NULL其实是一个宏，就是0
- nil
  - 只能作为指针变量的值，代表这个指针变量不指向内存中的任何空间
  - nil其实也等价于0，也是一个宏，就是0
  - 所以，NULL和nil其实是一样的
- 同类型的指针变量之间可以相互赋值
- 目前为止，只要看到了 new，就说明新创建了一个对象。
- 最容易犯错
  - @interface 是类的声明，@implementation 是类的实现，他们之间不能相互嵌套
  - 类必须先声明然后实现
  - 类的声明和实现必须都要有，就算没有方法，类的实现也必不可少
  - 类的声明必须要放在使用类的前面，实现可以放在使用类的后面
  - 声明类的时候，类的声明和实现必须要同时存在，特殊情况下可以只有实现，没有声明
  - 属性名一定要以下划线开头
  - 属性不允许声明的时候初始化
  - OC方法必须要创建对象通过对象名来调用
  - 方法只有声明，没有实现
- 推荐的方式
  - 把一个类写在一个模块之中，而一个模块至少包含两个文件
  -  .h头文件 写类的声明
  - .m实现文件 写上类的实现
- 在类方法中不能直接访问属性
  - 属性是在对象创建的时候，跟随者对象一起创建在对象之中
  - 类第一次被访问的时候，会做类加载，是吧类的加载存储在代码段
- %p 打印的是指针变量的值
- %@ 打印的是指针变量指向的对象
- 面向对象的三大特征：
  - 封装
    - 类就是更高级别的封装。类将数据和行为封装为了一个整体
    - 好处：
      - 屏蔽内部的实现，外界不需要知道内部是如何实现的，只需要知道这个对象有什么用。
      - 方便操作
      - 后期的维护十分的便利。
  - 继承
  - 多态
- 如何实现这个需求
  - 将属性的 @public 去掉，因为一旦写上 @public 就意味着外界可以直接访问对象的这个属性。外界一旦可以直接访问这个属性，那么外界就可以任意的为这个属性赋值。
    - 去掉 @public，外界就无法直接访问这个属性，也就无法赋值了
  - 为类提供一个方法，这个方法专门为这个属性赋值，这个方法叫做 setter
    - 这个方法一定是一个对象方法，因为这个要为属性赋值
    - 这个方法没有返回值，因为这个方法做的事情，仅仅是为属性赋值就可以了
    - 这个方法的名称必须以 set 开头，跟上去掉下划线首字母大写的属性名。
    - 这个方法一定是有参数的。参数的类型和属性的类型一致。参数的名称和属性的名称一致（去掉下划线）。
    - 在方法的实现中，判断传入的数据是否符合逻辑，如果符合逻辑则赋值，否则做默认处理。
    - 外界想要为对象的属性赋值，那么就调用这个对象的 setter 方法，将要赋值的数据传入给这个方法。方法会对这个数据进行验证，如果符合验证，就会把数据赋值给属性，否则就会做默认处理。